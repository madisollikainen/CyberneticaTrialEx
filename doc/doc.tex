\documentclass[11pt]{article}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={165mm,240mm},
 left=22.5mm,
 top=25mm,
 }


\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage[us]{datetime}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage[font=small,labelfont=bf]{subcaption}
\usepackage{listings}
\usepackage{color}
\usepackage{multicol}
\usepackage{placeins}



\usepackage{graphicx}
\usepackage{caption}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
% \lstset{language=C}%,caption={Descriptive Caption Text},label=DescriptiveLabel}
% \renewcommand{\lstlistingname}{Code}
\usepackage{cleveref}
\crefname{equation}{equation}{equations}
\crefname{figure}{figure}{figures}
% \crefname{lstlisting}{code}{codes}
% \Crefname{lstlisting}{Code}{Codes}

\setlength{\parindent}{0in}
\usepackage[parfill]{parskip}

\usepackage[round]{natbib}
\bibliographystyle{plainnat}


% \usepackage{fancybox}
% \usepackage{tikz}

%% Input my macrosetup %%
% \input{macrosetup.tex}

%% C++ 
\newcommand{\CC}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf +}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}
\def\CC{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny\bf ++}} }

%% Text style for code
\usepackage{xspace}
\newcommand{\ct}[1]{\texttt{#1}}
\newcommand{\SC}{\ct{SecreC}\xspace}




\author{Madis Ollikainen}
\title{Trial exercise for Cybernetica Sharemind team}

\begin{document}

\maketitle

In the following I'll describe my solution of the trial exercise given to me by the Sharemind team of Cybernetica AS.

\section{Task overview} % (fold)
\label{sec:task_overview}

Sharemind is a secure multi-party computation based database/application server, which allows processing of encrypted data with out the need for decryption. Applications on the Sharemind server are written in the \SC programming language, which separates private and public data on a type system level. The Sharemind SDK provides contains the \SC language and compilers as well as a Sharemind server emulator for testing. For my trial exercise I had to familiarise myself with Sharemind SDK and solve a few tasks related to implementing/analysing selection algorithms.

Selection algorithms are algorithms for finding the $k$-th order statistic, \emph{i.e} the $k$-th smallest entry, from a list or array. In my trial exercise, the focus was on $1$D arrays. More specifically, my tasks were

\begin{enumerate}
      	\item Implement a function \ct{D int64 nthElementSort (D int64[[1]] data, uint64 k)}, which returns the $k$-th smallest element from the input array \ct{data} by first sorting the input array using the sorting function from the \SC standard library.

      	\item Compare the sorting based \ct{nthElementSort} with the \SC standard library selection algorithm \ct{nthElement}: (a) Which of them is more efficient? (b) Which of them leaks more information based on its run time? 

      	\item Implement an oblivious sorting based selection algorithm \ct{D int64 nthElementSortOblivious (D int64[[1]] data, D uint64 k)}. In this context, oblivious refers to the fact that both of the inputs \ct{data} and \ct{k} are private. In the function header this is indicated with specifying the privacy type with \ct{D} (public privacy types do not have to be specified). 

      	\item Implement an oblivious selection algorithm \ct{D int64 nthElementOblivious (D int64[[1]] data, D uint64 k)}, which is based on the \SC standard library function \ct{nthElement}. Who does this impact the efficiency of the algorithm and run time information leakage? 
\end{enumerate}      

For each implemented function I should, of course, present testing functions and a short documentation. 

% section task_overview (end)

\section{Solutions} % (fold)
\label{sec:solutions}

In this section, I'll shortly present the main ideas of my solutions and answer the questions posed in \cref{sec:task_overview}. 

\subsection{Function \ct{nthElementSort}} % (fold)
\label{sub:nthelementsort}

The sorting based $k$-th smallest element selection algorithm is rather straight forwards: (1) sort the input; (2) return the $k$-th element from the sorted array. \Cref{lst:nthElementSort} demonstrates the implementation of the \ct{nthElementSort} function. It is templated on the privacy type \ct{D}.  

\begin{lstlisting}[caption={The \ct{nthElementSort} function, which is templated on the privacy type \ct{D}.}, label={lst:nthElementSort}, language=C++]
template<domain D>
D int64 nthElementSort (D int64[[1]] data, uint64 k){    
    data = sort(data); 	// Sort the input array
    return data[k];	// Return the k-th smallest value
}
\end{lstlisting}

The file \ct{src/nthElementSort.sc} implements the module \ct{nthElementSort}, consisting of the function \ct{nthElementSort} and a test function \ct{test\_nthElementSort}. For running the test, the file \ct{src/run\_nthElementSortTest.sc} has to be compiled and executed. 

% subsection nthelementsort (end)

\subsection{Comparison of \ct{nthElementSort} and \ct{nthElement}} % (fold)
\label{sub:comparison_of_nthelementsort_and_nthelement}

In this section, I'll compare the efficiency and run time information leakages of the sorting based selection algorithm \ct{nthElementSort} and the \SC standard library selection algorithm \ct{nthElement}. As seen in \cref{sub:nthelementsort}, the function \ct{nthElementSort} consisted of calling the standard library function \ct{sort} and a single array access. Therefore, the comparison can be done between the two standard library functions: \ct{sort} and \ct{nthElement}. I'll start by describing the logic behind these two functions. 

\subsubsection{The \ct{sort} function} % (fold)
\label{ssub:the_sort_function}
 
The number of operations done in the \ct{sort} function implemented in the \ct{shared3p\_sort} module only depends on the size of the input $N$ and scales quadratically with $N$. Furthermore, for any input with size $N$ the run time is the same, \emph{i.e} the best case, average case and worst case scenarios are the same and all scale quadratically of the input size $O(N^2)$.   

 % subsubsection the_sort_function (end) 

\subsubsection{The \ct{nthElement} function} % (fold)
\label{ssub:the_nthelement_function}

The \ct{nthElement} function in the \ct{shared3p\_statistics\_common} module is an implementation of the \ct{QuickSelect} algorithm, whose main workhorse is the partitioning subroutine. It takes as an input an array and an index or a pointer specifying a certain entry in the array, which is called a ``pivot''. The partitioning function does a single sweep of the input array and re-arranges the entries such, that all of the entries on the left hand side of the pivot are smaller than the pivot and all on the right hand side are larger than it.     

% subsubsection the_nthelement_function (end)

% subsection comparison_of_nthelementsort_and_nthelement (end)

% section solutions (end)



% \bibliography{Guardtime.bib}

\end{document}